// @Notice: Test Suite for common exploits (Template).
// @Author: ðŸ‘½ @CrystallineButterfly (K42) ðŸ‘½

const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Sample Smart Contract", function () {
  let sampleContract;
  let owner;
  let attacker;
  let user1;
  let user2;
  let user3;

  beforeEach(async function () {
    [owner, attacker, user1, user2, user3] = await ethers.getSigners();
    const SampleContract = await ethers.getContractFactory("SampleContract");
    sampleContract = await SampleContract.connect(owner).deploy();
    await sampleContract.deployed();
  });

  describe("Reentrancy", function () {
    it("should prevent reentrancy attacks", async function () {
      // Deploy and prepare the attacker contract
      const attackerContract = await ethers.getContractFactory(
        "AttackerContract"
      );
      const attackerInstance = await attackerContract
        .connect(attacker)
        .deploy(sampleContract.address);
      await attackerInstance.deployed();

      // Make the attacker contract call the vulnerable function
      await expect(attackerInstance.attack()).to.be.revertedWith(
        "reentrant call"
      );

      // Verify that the contract state hasn't been changed by the attacker
      expect(await sampleContract.balanceOf(attacker.address)).to.equal(0);
      expect(await sampleContract.balanceOf(user1.address)).to.equal(100);
    });
  });

  describe("Integer Overflow/Underflow", function () {
    it("should prevent integer overflow/underflow", async function () {
      // Attempt to overflow the balance
      await expect(
        sampleContract.transfer(user1.address, ethers.constants.MaxUint256)
      ).to.be.revertedWith("integer overflow");

      // Attempt to underflow the balance
      await sampleContract.transfer(user1.address, 50);
      await expect(
        sampleContract.transfer(user2.address, 100)
      ).to.be.revertedWith("integer underflow");
    });
  });

  describe("Arbitrary Message Sending", function () {
    it("should prevent arbitrary message sending", async function () {
      // Attempt to send a message from an unauthorized account
      await expect(
        sampleContract.connect(attacker).transfer(user1.address, 50)
      ).to.be.revertedWith("unauthorized");

      // Verify that the contract state hasn't been changed by the attacker
      expect(await sampleContract.balanceOf(attacker.address)).to.equal(0);
      expect(await sampleContract.balanceOf(user1.address)).to.equal(100);
    });
  });

  describe("Front-Running", function () {
    it("should prevent front-running attacks", async function () {
      // Deploy and prepare the attacker contract
      const attackerContract = await ethers.getContractFactory(
        "FrontRunningAttacker"
      );
      const attackerInstance = await attackerContract
        .connect(attacker)
        .deploy(sampleContract.address);
      await attackerInstance.deployed();

      // Make the attacker contract call the vulnerable function
      await attackerInstance.attack({ value: ethers.utils.parseEther("1") });

      // Verify that the contract state hasn't been changed by the attacker
      expect(await sampleContract.balanceOf(attacker.address)).to.equal(0);
      expect(await sampleContract.balanceOf(user1.address)).to.equal(100);
    });
  });

  describe("Timestamp Dependence", function () {
    it("should prevent timestamp dependence attacks", async function () {
      // Deploy and prepare the attacker contract
      const attackerContract = await ethers.getContractFactory(
        "TimestampAttacker"
      );
      const attackerInstance = await attackerContract
        .connect(attacker)
        .deploy(sampleContract.address);
      await attackerInstance.deployed();

      // Verify that the attacker contract can't access the vulnerable function
      await expect(attackerInstance.attack()).to.be.revertedWith(
        "unauthorized"
      );

      // Verify that the contract state hasn't been changed by the attacker
      expect(await sampleContract.balanceOf(attacker.address)).to.equal(0);
      expect(await sampleContract.balanceOf(user1.address)).to.equal(100);
    });
  });

  describe("Block Number Dependence", function () {
    it("should prevent block number dependence attacks", async function () {
      // Deploy and prepare the attacker contract
      const attackerContract = await ethers.getContractFactory(
        "BlockNumberAttacker"
      );
      const attackerInstance = await attackerContract
        .connect(attacker)
        .deploy(sampleContract.address);
      await attackerInstance.deployed();

      // Verify that the attacker contract can't access the vulnerable function
      await expect(attackerInstance.attack()).to.be.revertedWith(
        "unauthorized"
      );
      // Advance the block timestamp by 1 hour
      await ethers.provider.send("evm_increaseTime", [3600]);

      // Verify that the attacker contract can't access the vulnerable function anymore
      await expect(attackerInstance.attack()).to.be.revertedWith(
        "unauthorized"
      );
    });
  });

  describe("Unprotected Ownership", function () {
    it("should prevent unprotected ownership attacks", async function () {
      // Attempt to transfer ownership to an unauthorized account
      await expect(
        sampleContract.transferOwnership(user1.address)
      ).to.be.revertedWith("unauthorized");
      // Verify that ownership hasn't been transferred
      expect(await sampleContract.owner()).to.equal(owner.address);
    });
  });
});

// @dev

// In this sample test suite, we cover the following exploits and bugs:

// - Reentrancy attacks: 
// We deploy an attacker contract that attempts to call the vulnerable contract's function multiple times before the initial call completes.
//  We expect the contract to revert with a message indicating a reentrant call.
//  We also verify that the contract state hasn't been changed by the attacker.

// - Integer overflow/underflow: 
// We attempt to overflow and underflow the balance of the vulnerable contract. 
// We expect the contract to revert with a message indicating an integer overflow or underflow, respectively.

// - Arbitrary message sending: We attempt to send a message from an unauthorized account. 
// We expect the contract to revert with a message indicating an unauthorized call. 
// We also verify that the contract state hasn't been changed by the attacker.

// - Front-running attacks:
//  We deploy an attacker contract that attempts to execute a transaction before the original transaction reaches the blockchain. 
//  We expect the contract to revert with a message indicating an unauthorized call. We also verify that the contract state hasn't been changed by the attacker.

// - Timestamp dependence attacks: 
// We deploy an attacker contract that attempts to access a vulnerable function that's only available within a certain timeframe. 
// We advance the block timestamp to simulate the passage of time and verify that the attacker contract can no longer access the vulnerable function.

// - Unprotected ownership attacks: 
// We attempt to transfer ownership to an unauthorized account. We expect the contract to revert with a message indicating an unauthorized call. 
// We also verify that ownership hasn't been transferred.
